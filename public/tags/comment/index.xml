<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>COMMENT on VZstless</title>
        <link>https://vzstless.moe/tags/comment/</link>
        <description>Recent content in COMMENT on VZstless</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>VZstless</copyright>
        <lastBuildDate>Thu, 06 Feb 2025 09:48:12 +0800</lastBuildDate><atom:link href="https://vzstless.moe/tags/comment/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>关于6.1810</title>
        <link>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E6.1810/</link>
        <pubDate>Thu, 06 Feb 2025 09:48:12 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E6.1810/</guid>
        <description>&lt;p&gt;终于，从寒假到现在磕磕绊绊算是把6.1810攻克了&lt;/p&gt;
&lt;p&gt;这个课分为几个部分，讲义，课本，xv6本身以及课程。讲义是给你稍微溜一眼这节课要干啥用的，课本的参考价值极高，几乎做实验过一会儿就要翻一下。xv6就不说了，公认的艺术品，功能齐全而且每个调用的路径都极其清晰，哪怕你不按课本瞎改一些部分看报错也是挺享受的。课，emm&amp;hellip;实在话，这个课是真干啊，真hacking啊，估计你讲义和书没看懂的话课程也看不懂。如果你没时间，只看Q&amp;amp;A就行了，代码示例可以跟着讲义自己弄。&lt;/p&gt;
&lt;p&gt;jyy曾说过操作系统是一门增加内功的课，哪怕你的编程能力并不足以支撑你完成这门课程，你以后还会不断地在学习生活中无数次被相同的概念callback。你更习惯于gdb了，你能够解释concurrency和parallelism的区别了，你看汇编代码更快了，你看GFS和MapReduce的时候看到大篇幅的logging想到了ext2+journaling=ext3，你看那些卖虚拟化容器的技术也会感觉“这真没啥”了。&lt;/p&gt;
&lt;p&gt;后来在课程实验快结束的时候你看到了OS-in-1000-lines，一个最初由日文写成的教程，补全了xv6没有告诉你的关于操作系统怎么从零开始的部分。它的代码不如xv6那么优雅，但是能让你真正体验一下什么叫“脏活累活”（点名批评virtio部分）&lt;/p&gt;
&lt;p&gt;实验？lazy-allocation在2023版中被砍掉了，最喜欢的应该是copy-on-write和syscall，一个是让你突然意识到错误处理原来不止是层层包裹的try-catch和Option，还可以用来实现各种花样繁多的新功能。syscall是让你游走在各个文件之间的一个实验，做完之后感觉用gdb比用IDE里头那些被阉割过的玩意儿顺手多了，也让你在RTFSC的时候更习惯于trace了&lt;/p&gt;
&lt;p&gt;总之，挺值得试试的，我对它的评价会远高于SICP和Algorithms。也许以后如果我大四的时候真的实在是闲的没事可能会尝试一下“上不封顶”的CS142？眼前的话，估计只能使用碎片时间增加一下os1000的其他功能了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>商学的死亡</title>
        <link>https://vzstless.moe/p/%E5%95%86%E5%AD%A6%E7%9A%84%E6%AD%BB%E4%BA%A1/</link>
        <pubDate>Mon, 30 Dec 2024 08:08:50 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%95%86%E5%AD%A6%E7%9A%84%E6%AD%BB%E4%BA%A1/</guid>
        <description>&lt;p&gt;理论上一个计算机都快学不明白的人不应该对外行的见识发表暴论，但既然学校选择了力推外专业“选修”，不修毕不了业，那我就不先礼后兵了&lt;br&gt;
许多人现如今已经不太看重所谓的MBA或者别的类似的商学学位，认为它们纯纯是二水货，事实证明他们没错。商学的死不是因为商学被什么别的哲学取代了，而是商学被计算机从思维意义上被取代了。这时候你大概率要问：是计算机代替了人力参与了商学相关的事务了吗？是也不是，因为不只是人类意义上的代替，还有思想层面的代替。&lt;br&gt;
几乎所有的管理学相关的思想在计算机哲学中都能找到代替品，而且研究层面上更加极端。流水线优化与对节拍异化为了CPU流水线性能优化，工作中心分配异化为了操作系统中的线程调度优化，公交线路布局异化为了找最长路径，观察次数异化为了单纯的统计题，工序优化异化为了对一个有向图进行拓扑排序，至于剩下的，大概率交给Excel或者大模型都可以完成。从思想和实践层面，计算机科学都直接毙掉了商学。&lt;br&gt;
也许商学的下一步应该把&lt;em&gt;UNIX编程艺术&lt;/em&gt;列为必读书目？但总之不应该是罗宾斯管理学这种老东西了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>生产力与生产关系</title>
        <link>https://vzstless.moe/p/%E7%94%9F%E4%BA%A7%E5%8A%9B%E4%B8%8E%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/</link>
        <pubDate>Mon, 16 Dec 2024 21:51:39 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E7%94%9F%E4%BA%A7%E5%8A%9B%E4%B8%8E%E7%94%9F%E4%BA%A7%E5%85%B3%E7%B3%BB/</guid>
        <description>&lt;p&gt;注：以下讨论不涉及C，Python和JavaScript，因为你不用也得用，迟早有一天你会被这仨语言中的一个找上茬儿&lt;/p&gt;
&lt;p&gt;马原课本告诉我们，生产力决定生产关系，生产关系反作用于生产力。我们可以使用这个理论来给计算机行业中的错误思想套公式。现在许多人中流传着Java焦虑，好像Java死了我的工作就彻底寄了，然后经典的中年危机就业焦虑。然而大概率事实是不是Java不行，而是你从始至终就没入行。换语言不会使你干好，反而你长期囿于原先的生产关系而没有意识到自己的生产力本身落后，换了语言，原形毕露，没有论坛可查，自己失去了debug和查找性能瓶颈的能力。类似的还有软件工程。首先，你大概率不是CEO之类的要职，而你的第一个demo做得并不好甚至没做出来，你就觉得现在的软件生产模型不行，想从瀑布模型转变成敏捷模型。然而你没注意到敏捷模型对生产力的要求是达到了一定境界的，你的生产力并不足以满足敏捷模型短期迭代的内在要求，大概率结局是项目流产。&lt;/p&gt;
&lt;p&gt;换一个视角，你应该在简历上写精通XXX语言吗？理论上不应该。这时候就有人问有人就看简历里头的这玩意儿你咋办嘛，我只能说这玩意儿只能反映你接触过这种生产关系，对于你的生产力没有任何反映。你用解释型编程语言大写特写for循环，最后的结果必定是慢的要死。当你想要入坑一个新的编程语言的时候，最好问问自己：&lt;/p&gt;
&lt;p&gt;&lt;br&gt;它和我知道的编程语言有没有本质区别？&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;学会C的人应该接触Python，因为Python是解释型，大量使用库函数的语言而C是编译型，造轮子的语言。Rust和C就没有本质区别，你最开始制作demo的时候对安全没有那样强烈的需求，甚至对cargo一类的项目管理器没什么需求，而你编程经验又不足，你就最好先别弄Rust，而是用C先做一个能跑的东西。&lt;/p&gt;
&lt;p&gt;最后，不妨思考一下这门语言为什么出现。C是UNIX的副产物，C++是为了改进C而产生的，Python脱胎于科学计算，Rust又被Mozilla用于浏览器内核的开发。从这个角度讲也许用Rust重构Chromium比用Rust重构Linux更现实？&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于一些网络热门课程</title>
        <link>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E8%AF%BE%E7%A8%8B/</link>
        <pubDate>Sun, 15 Dec 2024 13:38:47 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E8%AF%BE%E7%A8%8B/</guid>
        <description>&lt;p&gt;事先声明，锐评不代表讨厌，相反，正是因为你有了足够的了解之后你才能知道为啥人家的课程好，我们的为什么烂。我感谢它们，在无数节水课中带我消磨时间，做有趣的事情。&lt;/p&gt;
&lt;h3 id=&#34;sicp&#34;&gt;SICP
&lt;/h3&gt;&lt;p&gt;SICP这个课可就有点儿历史了，上世纪80年代，Abelson和Sussman这俩人用他们编写的教科书改造了MIT的计算机入门课程。它主要使用Lisp的一门方言——MIT Scheme进行编程，讲解关于计算机思维与计算方法的基础知识。现在网上流传的始祖SICP实质上是两个教授去惠普公司进行的讲座，不过内容大同小异就是了。说是基础，但是这个课联同这本书都是极其折磨的。&lt;/p&gt;
&lt;p&gt;首先，Scheme，或者说Lisp系的语言只能写递归不能写迭代。这门课程的起初就在不断地教你如何递归展开。随后便是一些时至今日也在使用的编程语言设计理念的雏形——数据结构，面向对象，流，乃至并发。不要用你学某个现代化程度很高的编程语言的经验简单套用在这里，Lisp的bare metal程度某种意义上不亚于C，许多的现有的知识要先有一层抽象才能转化成Lisp的东西。以及这本书会大量地造轮子。造图片编程语言，造小型SQL，造基于Lisp-Like汇编语言的寄存器机器。对，某种意义上你现有的对于计算机的知识都被颠覆了，这本书告诉你只要有了Lisp你能造出来所有东西！&lt;/p&gt;
&lt;p&gt;当时学的时候我用了先看课再看书的策略，结果发现书上的题目和前头的知识完全就是雕花和切冻肉的关系（笑）。经常有第一题“来，仿照那个加法程序造一个乘法程序”，第二题“来，刚才用迭代写的同学转化成递归来写，刚才用递归的同学用迭代来写！”，第三题“你看，加法和乘法可以抽象成XXX，这个程序怎么写呢？”，第四题又是迭代换递归，递归换迭代，第五题又再抽象一层，抽象到最后还不忘问你一句“嘿，你觉得你的设计真的合理吗？”，绝大多数情况下我做到第三题就破大防去抄答案了。&lt;/p&gt;
&lt;p&gt;第四章和第五章虽说是讲evaluator，SQL和寄存器机器这种显而易见的东西，但是在书里头这玩意儿又被一层又一层抽象了。后来我转念一想“估计这点儿玩意儿我这辈子都用不上了”，就去做了一下“Build your own Lisp”，把第四章和第五章的课程录像看完了就跑了。&lt;/p&gt;
&lt;p&gt;现在想想UCB和MIT把这个课程改成Python，SQL和Lisp真是明智的选择。他们从函数入手而不是递归，大大降低了这门课程的门槛，第四章原来的造轮子变成了摆在眼前的SQL，之于更高层次的抽象则交给了Lisp。Sussman曾经暗讽过这个课程改变是让人做脱离系统的调包侠，但是调包不也是优化程序的一种有效手段吗？何况这个课程的教授方式也大变了，先让你熟悉终端，相关硬件的下载和从网站上获取压缩包。这个知识屏蔽已经到极致了。没有git，没有链接，没有过于繁杂的命令行，总之个人认为这个课程进步了很多。&lt;/p&gt;
&lt;p&gt;有人会问推不推荐学CS61A，我说你要是大佬休闲想学学无所谓。至于老版的SICP和配套的那本书，实在话，还是直接进入历史的故纸堆就好。我读过了，不建议你走同样的路。顺带一提，负责原始版本SICP翻译的HIT IBM俱乐部今日也某种意义上“半死不活”了。&lt;/p&gt;
&lt;h3 id=&#34;algorithms&#34;&gt;Algorithms
&lt;/h3&gt;&lt;p&gt;最初接触这玩意儿的时候是我淘书的时候发现的人民邮电出版社的中译本，“与TAOCP相媲美的神作”，豁，那可得看看咯。结果第一章就看不懂了，作者居然自己搓了个Java标准库用，还得自己配，然后就是极其痛苦的配环境，最后环境没弄成，这本书就吃灰了。&lt;/p&gt;
&lt;p&gt;后来听人说Sedgewick的课比书好，我就去看课，看完就用C++尝试把示例代码重构了。但是有一整章的代码我都重构失败了，就是图算法。这本书绝大多数的代码都依赖于作者自己搓的标准库中的API，这就导致图算法重构的时候源代码毫无参考性，你就只能去诸如OI wiki的地方寻找。我严重怀疑这个所谓的“抽象数据结构”的思想给国内诸如严蔚敏《数据结构》一类的差评如潮的教材开了个坏头。如果我都无法将你的算法思维进行有效的迁移，那你这个课又有什么用呢？&lt;/p&gt;
&lt;p&gt;有！确切来讲是另一种意义上的。这门课会告诉你专业人士是怎么研究算法的。而且这个课很“新”。2007年Sedgewick将Red-Black BST进行了简化，变成了LLRB-BST，2012年，这个研究就被写入了教材。某种意义上这门课程给了你一种“这个算法牛逼吗？我发明的！”的一种震撼。&lt;/p&gt;
&lt;p&gt;于你而言这门课其实只需要看四个地方：开头的并查集优化，快速排序在大量重复关键字下的优化，左斜红黑树和3-Way Trie。这几个算法各有特色，而且有Sedgewick教授的原创成分。相信我，当你看见demo中的红黑树就像被赋予生命了一样自动平衡的时候你会发自内心大吼一句“卧槽”的。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
