<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>XV6 OS on VZstless</title>
        <link>https://vzstless.moe/tags/xv6-os/</link>
        <description>Recent content in XV6 OS on VZstless</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>VZstless</copyright>
        <lastBuildDate>Sun, 12 Jan 2025 16:14:43 +0800</lastBuildDate><atom:link href="https://vzstless.moe/tags/xv6-os/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>xv6 LECTURE6</title>
        <link>https://vzstless.moe/p/xv6-lecture6/</link>
        <pubDate>Sun, 12 Jan 2025 16:14:43 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture6/</guid>
        <description>&lt;h2 id=&#34;handout-6&#34;&gt;Handout 6
&lt;/h2&gt;&lt;p&gt;focusing on user-&amp;gt;kernel transition&lt;br&gt;
NEVER execute user code in supervisor mode&lt;br&gt;
C on RISC-V puts function arguments in a0, a1, a2, &amp;amp;c&lt;/p&gt;
&lt;p&gt;check pagetables: C-a c, info mem&lt;br&gt;
trampoline: the start of kernel&amp;rsquo;s trap handling code&lt;br&gt;
at the top: avoid punch a hole in user addr&lt;/p&gt;
&lt;p&gt;observe PC is an indirect way to check whether we&amp;rsquo;re in supervisor mode&lt;/p&gt;
&lt;p&gt;ecall:&lt;br&gt;
change mode, save PC in SEPC, jump to STVEC, disable further interrupts&lt;br&gt;
ecall does as little as possible&lt;br&gt;
even supervisor mode is constrained to use pgtbl&lt;/p&gt;
&lt;p&gt;save the user registers:&lt;br&gt;
using trapframe or the sscratch register&lt;/p&gt;
&lt;p&gt;why not a crash? we just switched page tables while executing&lt;br&gt;
the trampoline is mapped at the same addr in pgtbls&lt;/p&gt;
&lt;p&gt;back to usertrap(), return $ and space&lt;br&gt;
usertrapret()&lt;br&gt;
prepare for next transition&lt;br&gt;
use sret instruction&lt;/p&gt;
&lt;p&gt;complex from isolation&lt;br&gt;
what if design for faster?&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-4&#34;&gt;Book Chapter 4
&lt;/h2&gt;&lt;p&gt;ecall &amp;amp; exception will cause a trap&lt;br&gt;
stvec: trap handler&lt;br&gt;
sepc: PC saver&lt;br&gt;
scause: cause of occurring a trap&lt;br&gt;
sscratch: avoid overwriting&lt;br&gt;
usertrap: determine the reason of trap&lt;br&gt;
usertrapret -&amp;gt; userret -&amp;gt; switch satp to user space -&amp;gt; load trapframe addr to a0 -&amp;gt; executes sret&lt;/p&gt;
&lt;p&gt;argint, argaddr, argfd retrieves n&amp;rsquo;th argument of integer, address or fd&lt;br&gt;
kernelvec: save regs, jump to kerneltrap, yield&lt;/p&gt;
&lt;h2 id=&#34;lecture-6&#34;&gt;Lecture 6
&lt;/h2&gt;&lt;p&gt;don&amp;rsquo;t let user code to interfere the transition between user and kernel code&lt;br&gt;
supervisor: R/W control regs, satp, stvec, sepc, sscratch, use PTE/PTE_U&lt;/p&gt;
&lt;p&gt;write() -&amp;gt; ecall -(user-&amp;gt;kernel)-&amp;gt; uservec -&amp;gt; usertrap() -&amp;gt; syscall() &amp;lt;-&amp;gt; sys_write() -&amp;gt; usertrapret() -&amp;gt; userret()&lt;/p&gt;
&lt;p&gt;the user code could only access memory with PTE_U flag&lt;br&gt;
(checking by C-a c, info mem)&lt;br&gt;
csrrw? swaps a0 and special temp register&lt;br&gt;
lack of crash, the status of pc -&amp;gt; we&amp;rsquo;re in supervisor mode&lt;br&gt;
OS cares lot about performance, so ecall never forces you to do stack operations&lt;br&gt;
struct trapframe stays in proc.h, using 32 slots to save registers&lt;/p&gt;
&lt;p&gt;when running shell, sscratch holds the pointer to trapframe&lt;br&gt;
save? beware overwrite&lt;br&gt;
the instructions not executed? we&amp;rsquo;re still in trampoline, where user VA = kernel VA&lt;/p&gt;
&lt;p&gt;what if switch to another process?&lt;br&gt;
we could only switch pgtbl on trampoline&lt;/p&gt;
&lt;p&gt;sret? re-enables interrupts, setting the PC same as sepc, switching user mode&lt;br&gt;
what happens in UIE?&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE5</title>
        <link>https://vzstless.moe/p/xv6-lecture5/</link>
        <pubDate>Thu, 09 Jan 2025 21:52:22 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture5/</guid>
        <description>&lt;h2 id=&#34;gdb&#34;&gt;GDB
&lt;/h2&gt;&lt;p&gt;step: one line of code at a time, jumps into the function&lt;br&gt;
next: jump over functions&lt;br&gt;
stepi, nexti: do same thing for asm code&lt;br&gt;
continue: run until next breakpoint&lt;br&gt;
finish: runs until the function ends&lt;/p&gt;
&lt;p&gt;break: set a breakpoint&lt;br&gt;
watch: stop whenever value changes&lt;br&gt;
x: prints the raw memory&lt;br&gt;
print: prints the expression&lt;br&gt;
info registers: print value of registers&lt;br&gt;
info frame: prints current stack frame&lt;/p&gt;
&lt;p&gt;set: change value of a variable&lt;/p&gt;
&lt;h2 id=&#34;handout-5&#34;&gt;Handout 5
&lt;/h2&gt;&lt;p&gt;overwrite return address will cause an infinite loop&lt;/p&gt;
&lt;h2 id=&#34;calling-conventions&#34;&gt;Calling Conventions
&lt;/h2&gt;&lt;p&gt;int in RISC-V is always 32-bit wide, while long is 32-bit wide in RV32 and 64-bit wide in RV64&lt;br&gt;
in RV64, int is sign-extended&lt;br&gt;
struct: pass first 8 pointer-words into register&lt;br&gt;
twice size as a pointer word: use an even-odd pair; more than twice: pass by reference&lt;/p&gt;
&lt;h2 id=&#34;lecture-5&#34;&gt;Lecture 5
&lt;/h2&gt;&lt;p&gt;since published, x86 adds 3 instructions per month&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.section .test
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.global sum_to
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;definition of .test is at &amp;lt;defs.h&amp;gt;&lt;/p&gt;
&lt;p&gt;focus: switch the layout window in gdb&lt;/p&gt;
&lt;p&gt;tmux:
C-b c: new window&lt;br&gt;
C-b p &amp;amp; C-b n: switch between terminals&lt;br&gt;
C-b %: vertical split&lt;br&gt;
C-b &amp;ldquo;: horizontal split&lt;br&gt;
C-b o: jump between splited windows&lt;/p&gt;
&lt;p&gt;apropos will display gdb built-in manual&lt;/p&gt;
&lt;p&gt;caller: not preserved, callee: preserved&lt;br&gt;
s0-s11 is for? maybe to give compiler flexibility&lt;/p&gt;
&lt;p&gt;stack frame generated by calls&lt;br&gt;
sp-&amp;gt;bottom of the stack&lt;br&gt;
fp-&amp;gt;top of the current frame&lt;/p&gt;
&lt;p&gt;i frame: show the message of stack frame&lt;br&gt;
backtrace&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE4</title>
        <link>https://vzstless.moe/p/xv6-lecture4/</link>
        <pubDate>Tue, 07 Jan 2025 18:57:30 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture4/</guid>
        <description>&lt;h2 id=&#34;handout-4&#34;&gt;Handout 4
&lt;/h2&gt;&lt;p&gt;what if a user program writes to a random part of memory?&lt;br&gt;
what way could we separate and isolate memory?&lt;br&gt;
page tables&lt;br&gt;
a level of indirection: CPU -(VM)&amp;gt; MMU -(PM)&amp;gt; MEM&lt;br&gt;
satp, MMU, kernel&lt;/p&gt;
&lt;p&gt;reduce the size of page tables, not building a direct-map&lt;/p&gt;
&lt;p&gt;page=4KB, maximum 52 bits, nowadays 27bits&lt;br&gt;
page table entry: 64 bits, 54 used, 10 of them are flags, low 12 bits of PA are from VA&lt;br&gt;
3-level page table to reduce its size&lt;br&gt;
a tree descended 9 bits at a time&lt;/p&gt;
&lt;p&gt;page-fault forces transfer to kernel&lt;br&gt;
PHYSTOP = 0x88000000&lt;/p&gt;
&lt;p&gt;the design and arrangement of user address space: easier for compiler to compile&lt;br&gt;
need contingous PM not VM&lt;/p&gt;
&lt;p&gt;kvmmake() makes kernel&amp;rsquo;s page table&lt;br&gt;
kvmmap() adds PTEs to a page table&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-3&#34;&gt;Book Chapter 3
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bits 25  27    12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;VA   EXT index offset
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bits      44  10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pagetable PPN flags
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bits 44    10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PA   index offset
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;TLB: avoid the cost of loading PTE&lt;br&gt;
write PA into satp register&lt;br&gt;
1 page table per process&lt;br&gt;
KERNBASE=0x80000000&lt;br&gt;
fork() uses parent&amp;rsquo;s virtual memory address directly&lt;br&gt;
trampoline and kernel stack aren&amp;rsquo;t directly-mapped&lt;/p&gt;
&lt;p&gt;pagetable_t: a pointer to root page table page&lt;br&gt;
walk() looks up for PTE&amp;rsquo;s VA&lt;br&gt;
instruction sfence.vma flushes CPU&amp;rsquo;s TLB&lt;/p&gt;
&lt;p&gt;allocator: keeps a free list of struct run&lt;br&gt;
kfree: set value to all 1&lt;/p&gt;
&lt;p&gt;refuse to execute, occur a page fault, kill the process and print the message&lt;br&gt;
make exploit attack harder by such a protection process&lt;/p&gt;
&lt;p&gt;sbrk() -&amp;gt; growproc() -&amp;gt; uvmalloc()/uvdemalloc() -&amp;gt; kalloc()/uvmunmap()
exec() -&amp;gt; namei() -&amp;gt; quick check -&amp;gt; proc_pagetable() -&amp;gt; loadseg() -&amp;gt; walkaddr()&lt;/p&gt;
&lt;p&gt;xv6 is lack of malloc()-like allocator to allocate small pieces of space&lt;/p&gt;
&lt;h2 id=&#34;lecture-4&#34;&gt;Lecture 4
&lt;/h2&gt;&lt;p&gt;What do we want from isolation?&lt;/p&gt;
&lt;p&gt;The VA_MAX could be larger than PA_MAX&lt;br&gt;
where does page table allocates? kalloc()&lt;br&gt;
there are 4096 bytes of continuous PA in PM, but not continuous for pages&lt;br&gt;
the size of PM is determined by designers&lt;br&gt;
satp is points to the top directory&lt;/p&gt;
&lt;p&gt;don&amp;rsquo;t use a translation scheme to rely on another translation scheme, so store PA in tables&lt;br&gt;
satp also stores PA&lt;br&gt;
why walk() ? initialization, sysinfo() needs walk()&lt;br&gt;
flexibility stays in dealing with page faults&lt;br&gt;
where will the data store? depends on a &amp;ldquo;multiplexer&amp;rdquo;&lt;br&gt;
mostly-identity mapping is used in kernel mapping&lt;/p&gt;
&lt;p&gt;stack overflow: page fault instead of covering other program&amp;rsquo;s memory&lt;br&gt;
consolidate the mapping? good, but xv6 didn&amp;rsquo;t do this action&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b kvminit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b kvminithart
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;where to store satp? in each proc structure, there&amp;rsquo;s a satp&lt;br&gt;
why 3-level not a single big table? you can remain many blocks empty&lt;br&gt;
etext is the last addr of kernel, KERNBASE=0x80000000, etext-KERNBASE=size of kernel&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE3</title>
        <link>https://vzstless.moe/p/xv6-lecture3/</link>
        <pubDate>Sun, 05 Jan 2025 09:49:10 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture3/</guid>
        <description>&lt;h2 id=&#34;handout-3&#34;&gt;Handout 3
&lt;/h2&gt;&lt;p&gt;No OS: lack of isolation&lt;br&gt;
fork() -&amp;gt; abstract core&lt;br&gt;
exec()/sbrk() -&amp;gt; abstract RAM&lt;br&gt;
assumption: user is always willing to break the isolation, while kernel is always trustable&lt;br&gt;
user mode and supervisor mode&lt;br&gt;
pgtbl: maps virtual-&amp;gt;physical&lt;br&gt;
ecall: change to supervisor mode, get to a known point of the kernel code&lt;/p&gt;
&lt;p&gt;Singularity provides a way of process isolation without hardware support&lt;/p&gt;
&lt;p&gt;kernel is a big program holds all of the syscalls&lt;br&gt;
On CVE there&amp;rsquo;s 2997 bugs detected on Linux in 2024(kernel bugs are much more common than we thought)&lt;/p&gt;
&lt;p&gt;build the kernel: make&lt;br&gt;
gcc compiles every .c, .o, linking, kernel/kernel, kernel/kernel.asm, produces an .iso&lt;br&gt;
run the OS: make qemu&lt;br&gt;
simulates the CPU, run into the first instruction in the OS&lt;/p&gt;
&lt;p&gt;kernel/entry.S -&amp;gt; start.c -&amp;gt; main()&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-2&#34;&gt;Book Chapter 2
&lt;/h2&gt;&lt;p&gt;Isolation can be done by protecting sensitive hardware from system calls&lt;br&gt;
monolithic kernel: the whole OS resides in the kernel&lt;br&gt;
micro kernel: minimalize code run in the supervisor mode&lt;br&gt;
in xv6, isolation is done by setting processes&lt;br&gt;
trampoline: contains the code from user space to kernel space&lt;br&gt;
trapframe: protects the status of the process&lt;br&gt;
sret instruction is used to return to user space from kernel space&lt;/p&gt;
&lt;p&gt;process: an addr space as a virtual RAM and an thread as a virtual CPU&lt;/p&gt;
&lt;p&gt;Boot a RISC-V Computer:&lt;br&gt;
power on -&amp;gt; run bootloader -&amp;gt; load kernel into memory address 0x80000000(I/O starts from here) and run into M mode -&amp;gt; set up a stack at _entry for runnning C code -&amp;gt; run into start of C -&amp;gt; program the clock chip to generate timer interrupts -&amp;gt; call useerinit to start the first syscall -&amp;gt; complete exec() -&amp;gt; return to user space and initialize the shell&lt;/p&gt;
&lt;h2 id=&#34;lecture-3&#34;&gt;Lecture 3
&lt;/h2&gt;&lt;p&gt;No strong isolation will cause memory overwrite, which will lead to a bug hard to debug&lt;br&gt;
OS should be defensive&lt;br&gt;
There is a flag to check whether the CPU is at user mode or kernel mode&lt;br&gt;
BIOS is always trustworthy&lt;/p&gt;
&lt;p&gt;fork() as a syscall hasn&amp;rsquo;t its function decalaration&lt;br&gt;
when calling fork: ecall sys_fork (here sys_fork is a number) -&amp;gt; syscall -&amp;gt; find number in a0 -&amp;gt; create a new process&lt;br&gt;
How to get control from buggy useer application? set a timer&lt;/p&gt;
&lt;p&gt;think qemu as a real circuit board&lt;br&gt;
qemu is an infinite for loop: fetch, decode, execute&lt;br&gt;
use gdb: b _entry; c; si; layout src;&lt;br&gt;
use n to goto next line of C code&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-43--44&#34;&gt;Book Chapter 4.3 &amp;amp; 4.4
&lt;/h2&gt;&lt;p&gt;(Before the labs&amp;hellip;)&lt;br&gt;
args for exec() in a0 &amp;amp; a1, syscall number in a7&lt;br&gt;
SYS_exec -&amp;gt; sys_exec&lt;br&gt;
return value in p-&amp;gt;trapframe-&amp;gt;a0&lt;/p&gt;
&lt;p&gt;fetchstr -&amp;gt; copyinstr -&amp;gt; walkaddr -&amp;gt; walk -&amp;gt; pagetable&lt;/p&gt;
&lt;h2 id=&#34;just-before-lab-syscall&#34;&gt;Just before Lab syscall&amp;hellip;
&lt;/h2&gt;&lt;p&gt;installing riscv64-unknown-elf-gdb:&lt;br&gt;
download the tar file from TUNA mirror site, unpack it, enter the current directory&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;../configure --prefix&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/local --target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;riscv64-unknown-elf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make -j &lt;span class=&#34;m&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;using-gdb&#34;&gt;using gdb
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;target remote localhost:26000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b syscall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout src
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;backtrace
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;p /x *p
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;p /x &lt;span class=&#34;nv&#34;&gt;$sstatus&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>xv6 LECTURE2</title>
        <link>https://vzstless.moe/p/xv6-lecture2/</link>
        <pubDate>Fri, 03 Jan 2025 22:12:02 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture2/</guid>
        <description>&lt;h2 id=&#34;handout-2&#34;&gt;Handout 2
&lt;/h2&gt;&lt;p&gt;memory layout:&lt;br&gt;
text: code, read-only data&lt;br&gt;
data: global C vars&lt;br&gt;
stack: local variables&lt;br&gt;
heap: sbrk, malloc, free&lt;br&gt;
.c -compile-&amp;gt; .o -link-&amp;gt; executable file&lt;br&gt;
strlen() uses array access while strcmp() uses pointer access&lt;br&gt;
kalloc() keeps a large linked list of free pages of memory&lt;br&gt;
LRU buffer cache is implemented as a dual-pointer linked list&lt;br&gt;
static: limited to the file where the variable is declared&lt;/p&gt;
&lt;h2 id=&#34;slides&#34;&gt;Slides
&lt;/h2&gt;&lt;p&gt;This class focus on RAM and I/O&lt;br&gt;
address space: represent bus as a giant array of data&lt;br&gt;
memory allocation: decide where array to store things&lt;br&gt;
A stack is much more smaller than heap&lt;/p&gt;
&lt;h2 id=&#34;kr&#34;&gt;K&amp;amp;R
&lt;/h2&gt;&lt;p&gt;alloc: use a stack to allocate memory space&lt;br&gt;
afree: pop the space and decrease the pointer&lt;br&gt;
the behavior is undefined for arithmetic or comparisons with pointers that do not point to members of the same array&lt;br&gt;
size_t is uint returned by sizeof()&lt;br&gt;
the result of modifying the string pointer is undefined&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE1</title>
        <link>https://vzstless.moe/p/xv6-lecture1/</link>
        <pubDate>Wed, 01 Jan 2025 08:28:39 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture1/</guid>
        <description>&lt;h2 id=&#34;handout-1&#34;&gt;Handout 1
&lt;/h2&gt;&lt;p&gt;Purpose of an OS:&lt;/p&gt;
&lt;p&gt;Isolate hard/software, virtualize hardware&lt;br&gt;
Interact with OS via syscalls&lt;br&gt;
First arg in syscall is FD&lt;br&gt;
UNIX I/O is 8-bit bytes&lt;/p&gt;
&lt;p&gt;When CPU receives a syscall:&lt;br&gt;
save, jump, execute, call, restore, reduce, jump back&lt;/p&gt;
&lt;p&gt;Shell is a user program instead of shell&lt;br&gt;
fork() lets us create a new process&lt;br&gt;
exec() replaces current process with an executable file&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-1&#34;&gt;Book Chapter 1
&lt;/h2&gt;&lt;p&gt;Operating system let different softwares use hardware together&lt;br&gt;
Process: instructions, data, stack&lt;br&gt;
fork() returns 0 in the child process while pid in the parent process&lt;br&gt;
wait() returns the pid and copies the exit status&lt;br&gt;
exec() loads a file and executes it&lt;/p&gt;
&lt;p&gt;file descripter refers to a file.&lt;br&gt;
fork() and exec()let the shell has the chance to redirect child&amp;rsquo;s I/O&lt;br&gt;
File descripter is a good abstraction&lt;/p&gt;
&lt;p&gt;Pipe is a small kernel buffer conncting files.&lt;br&gt;
Pipe: auto-clean, pass long data, allow parallel execution&lt;/p&gt;
&lt;p&gt;Underlying file is called inode&lt;br&gt;
cd is built-in, if not, the shell will form a infinity process tree of dir-changing&lt;/p&gt;
&lt;p&gt;ALL XV6 PROGRAMS RUN AS ROOT!!!!!&lt;/p&gt;
&lt;h2 id=&#34;amusement-unix&#34;&gt;Amusement: UNIX
&lt;/h2&gt;&lt;p&gt;In order to avoid large amount of team population and project cost, we need to build a good programming environment. UNIX is for building such an environment.&lt;br&gt;
PROBLEM: Large number of softwares, large scale of jobs&lt;br&gt;
Software is always demanded for different operations, to avoid rewrite code per annum, the code should be divided into modules.
Layers: kernel, shell, util&lt;br&gt;
A show of pipes&lt;br&gt;
Easy and packed pattern-matching algorithms&lt;br&gt;
Refer file as a simple sequence of bytes, file is contained in directories&lt;br&gt;
Concept of I/O redirection&lt;br&gt;
C: If you need to avoid hardware, simply use it; but also ways to interact with hardware directly&lt;br&gt;
An example of a software, inputting boolean equation and outputting circuit traces&lt;br&gt;
Computer is built for easy to use&lt;/p&gt;
&lt;h2 id=&#34;lecture-1&#34;&gt;Lecture 1
&lt;/h2&gt;&lt;p&gt;What would a kernel do?&lt;br&gt;
Everyone thought OS provides what they already know&lt;br&gt;
Many tensions occurred in OS design&lt;br&gt;
Func call vs Syscall? func hasn&amp;rsquo;t previlege to access real CPU and mem but syscalls have&lt;br&gt;
High-level language is designed to be portable&lt;br&gt;
There is a rule that we read from fd 0 and write to fd 1&lt;br&gt;
Kernel holds a process table and guided by fd&lt;br&gt;
Instruction ecall passes the system from user space to the kernel space&lt;br&gt;
Parent and child process shares the same fd&lt;br&gt;
exec() loads the program in the file and throw away current process&lt;br&gt;
exec() remains the fd that already exists&lt;br&gt;
wait() waits the child process to return, if the process hasn&amp;rsquo;t child process, it&amp;rsquo;ll return -1&lt;/p&gt;
&lt;h2 id=&#34;just-before-lab-util&#34;&gt;Just before Lab util&amp;hellip;
&lt;/h2&gt;&lt;p&gt;installing the riscv64-unknown-elf-gcc:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install &lt;span class=&#34;nv&#34;&gt;gcc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;riscv64-unknown-elf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
