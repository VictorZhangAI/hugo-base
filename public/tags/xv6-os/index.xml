<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>XV6 OS on VZstless</title>
        <link>https://vzstless.moe/tags/xv6-os/</link>
        <description>Recent content in XV6 OS on VZstless</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>VZstless</copyright>
        <lastBuildDate>Sun, 19 Jan 2025 07:11:18 +0800</lastBuildDate><atom:link href="https://vzstless.moe/tags/xv6-os/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>xv6 LECTURE10</title>
        <link>https://vzstless.moe/p/xv6-lecture10/</link>
        <pubDate>Sun, 19 Jan 2025 07:11:18 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture10/</guid>
        <description>&lt;h2 id=&#34;handout-10&#34;&gt;Handout 10
&lt;/h2&gt;&lt;p&gt;kernel must deal with parallel syscalls&lt;br&gt;
race between two cores calling kfree() leads to a page losing&lt;br&gt;
if multiple cores calls the lock, only one will be returned, other will wait until the lock release&lt;br&gt;
auto locking? needs explicit comtrol over different regions of code&lt;br&gt;
deadlocking problem&lt;br&gt;
locks are often not private business of modules&lt;br&gt;
lock &amp;amp; parallelism may require a whole re-write for the project!&lt;br&gt;
use big lock first, big lock is always enough&lt;br&gt;
check and re-lock the lock atomically, pushing down the question into hardware&lt;/p&gt;
&lt;p&gt;spinlock: if locked=1, again the loop, if locked=0, set it to 1, return 0&lt;br&gt;
if you use locks, you don&amp;rsquo;t need to understand the memory ordering rules, you need them if you want to write exotic &amp;ldquo;lock-free&amp;rdquo; code&lt;/p&gt;
&lt;p&gt;in RISC-V:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;a5 = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;s1 = &amp;amp;lk-&amp;gt;locked
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;amoswap.w.aq a5, a5, (s1)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;book-chapter-6&#34;&gt;Book Chapter 6
&lt;/h2&gt;&lt;p&gt;concurrency: multiple instruction streams are interleaved&lt;br&gt;
wait() frees child&amp;rsquo;s memory&lt;br&gt;
race: the location is accessed concurrently&lt;br&gt;
critical section: code covered in acquire() and release()&lt;br&gt;
invariants: properties of data structures maintained across operations&lt;/p&gt;
&lt;p&gt;traditional approach:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(;;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;two cores may reach line 43 at the same time!&lt;br&gt;
amoswap r, a&lt;br&gt;
swaps the value in address a and register r&lt;br&gt;
kalloc: a single free list protected by single big lock&lt;br&gt;
deadlock: a program requires A to B, the other program requires B to A&lt;br&gt;
deadlock requires global lock aquisition&lt;/p&gt;
&lt;p&gt;file system contains a huge lock-chain&lt;br&gt;
re-entrant lock: recursive lock&lt;br&gt;
acquire the lock again: allow the action&lt;br&gt;
if a spinlock is used by an interrupt handler, a CPU must never hold that lock with interrupts enabled&lt;/p&gt;
&lt;p&gt;nesting level of locks: acquire() calls push_off(); release() calls pop_off();&lt;br&gt;
__sync_synchronize() tells the compiler not to re-order the code, in fact, it&amp;rsquo;s a memory barrier&lt;/p&gt;
&lt;p&gt;sleeplock: not occupying the core for the lock could last for a long time&lt;/p&gt;
&lt;p&gt;lock can be expensive if CPU requires the same lock at the same time&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-9&#34;&gt;Book Chapter 9
&lt;/h2&gt;&lt;p&gt;acquire() and yield() are released in the scheduler thread&lt;br&gt;
inode acts as a shard lock&lt;br&gt;
implementation of spinlock: no lock at all&lt;br&gt;
scheduler, different process call fork() at the same time&lt;/p&gt;
&lt;h2 id=&#34;lecture-10&#34;&gt;Lecture 10
&lt;/h2&gt;&lt;p&gt;(TODO)&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE9</title>
        <link>https://vzstless.moe/p/xv6-lecture9/</link>
        <pubDate>Thu, 16 Jan 2025 23:24:27 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture9/</guid>
        <description>&lt;h2 id=&#34;handout-9&#34;&gt;Handout 9
&lt;/h2&gt;&lt;p&gt;CPU &amp;amp; devices: complicated &amp;amp; parallel&lt;br&gt;
most code in modern OSes are device drivers&lt;br&gt;
UART, RS232 port&lt;br&gt;
UART &amp;amp; FIFO: not using a busy loop, but using interrupts&lt;br&gt;
UART interrupts if: rx FIFO goes from empty to not-empty, or tx FIFO goes from full to not-full&lt;/p&gt;
&lt;p&gt;device interrupts: device -&amp;gt; PLIC -&amp;gt; trap -&amp;gt; usertrap()/kerneltrap() -&amp;gt; devintr()&lt;br&gt;
interrupt just means the state of device is changed&lt;br&gt;
the bottom-half of interrupt doesn&amp;rsquo;t run in the context of top-half&lt;br&gt;
registers: sie(supervisor interrupt enabled), PLIC claim: get next IRQ, sstatus&lt;/p&gt;
&lt;p&gt;kernelvec is like trampoline for kernel&lt;br&gt;
executing syscall in kernel, save in some proc&amp;rsquo;s stack&lt;/p&gt;
&lt;p&gt;multiple devices? deliver to different CPU or stay pending&lt;br&gt;
disable interrupts? clear SIE, using intr_off(), remember the pending interrupts, deliver when kernel re-enables interrupts&lt;br&gt;
many places has parallelism, the operation msy not atomic!&lt;br&gt;
using producer-consumer buffer&lt;/p&gt;
&lt;p&gt;trampoline cannot tolerate a second interrupt to trampoline!&lt;br&gt;
polling strategy: Top-half loops until device says it is ready&lt;br&gt;
use DMA is more efficient&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-5&#34;&gt;Book Chapter 5
&lt;/h2&gt;&lt;p&gt;dispatch happens in devintr()&lt;br&gt;
top-half: kernel thread, bottom-kernel: executes at interrupt time&lt;br&gt;
UART appears as a series of memory-mapped registers&lt;br&gt;
use consoleinit() to init UART hardware&lt;br&gt;
transmit complete&lt;br&gt;
init() will let the shell read the console&lt;/p&gt;
&lt;p&gt;read() -&amp;gt; consoleread() -&amp;gt; sleep()&lt;br&gt;
devintr() -(UART)-&amp;gt; uartintr() -&amp;gt; consoleintr()&lt;br&gt;
each time the UART finishes sending a byte, it generates an interrupt.&lt;br&gt;
in write(), uartintr() -&amp;gt; uartstart()&lt;br&gt;
allowing processes to execute concurrently with device I/O&lt;/p&gt;
&lt;p&gt;in RISC-V, timer interrupt happens in M mode&lt;br&gt;
start.c executes before main, to program CLINT hardware, set up a scratch area, set mtvec to timeervec&lt;br&gt;
The kernel could be made somewhat simpler if device and timer interrupts only
occurred while executing user code.&lt;/p&gt;
&lt;h2 id=&#34;lecture-9&#34;&gt;Lecture 9
&lt;/h2&gt;&lt;p&gt;save, process, resume&lt;br&gt;
asynchronous, concurrency, program devices&lt;br&gt;
How the &amp;lsquo;$&amp;rsquo; appears, and what happens after ls ?&lt;br&gt;
PLIC: 53 interrupt connect from devices&lt;br&gt;
core hold interrupt&lt;/p&gt;
&lt;p&gt;Driver manages device&lt;br&gt;
interrupt handler: top, bottom, a queue in it with read/write interface&lt;br&gt;
the queue is used to decouple top &amp;amp; bottom&lt;br&gt;
programming device: memory-mapped I/O; ld/st&lt;br&gt;
the kernel and the device should make a protocol&lt;/p&gt;
&lt;p&gt;$: device put it into UART, UART gen interrupts when the char has been sent&lt;br&gt;
ls: keyboard connect to receive line, generate interrupt&lt;/p&gt;
&lt;p&gt;RISC-V support:&lt;br&gt;
SIE: 1 bit for external interrupt&lt;br&gt;
SSTATUS: bit enable/disable&lt;br&gt;
SIP: interrupt pending&lt;br&gt;
SCAUSE: the cause of interrupt&lt;br&gt;
STVEC: holds address for the switching&lt;/p&gt;
&lt;p&gt;plicinit(): take interrupt from the devices&lt;br&gt;
more initialization in main.c, main() finally calls scheduler()&lt;/p&gt;
&lt;p&gt;init.c: creates a device as console&lt;br&gt;
shell itself writes into fd 2&lt;/p&gt;
&lt;p&gt;a pointer to producer and a pointer to consumer&lt;/p&gt;
&lt;p&gt;Interrupt:&lt;br&gt;
If SIE bitset: clear SIE bits&lt;br&gt;
sepc&amp;lt;-pc, save current mode, entering supervisor mode, pc&amp;lt;-stvec&lt;/p&gt;
&lt;p&gt;interrupts &amp;amp; concurrency:&lt;br&gt;
devices &amp;amp; CPU run in parallel, interrupt stops current program&lt;br&gt;
top &amp;amp; bottom deliver may run in parallel&lt;br&gt;
producer &amp;amp; consumer: read after write, using a queue&lt;/p&gt;
&lt;p&gt;once, interrupt was fast, now, interrupt is slow.&lt;br&gt;
solution: polling &lt;br&gt;
dynamic switch&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE8</title>
        <link>https://vzstless.moe/p/xv6-lecture8/</link>
        <pubDate>Wed, 15 Jan 2025 10:29:46 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture8/</guid>
        <description>&lt;h2 id=&#34;handout-8&#34;&gt;Handout 8
&lt;/h2&gt;&lt;p&gt;pgtbl is hard to debug, why?&lt;br&gt;
how to speed up syscall? Linux has vDSO&lt;br&gt;
vDSO enables virtual syscalls&lt;br&gt;
511: trampoline&lt;br&gt;
510: trapframe&lt;br&gt;
509: USYSCALL&lt;/p&gt;
&lt;p&gt;protection bits? URV, WRV, XRV&lt;br&gt;
scan all pages could be expensive!!&lt;/p&gt;
&lt;h2 id=&#34;slides-8&#34;&gt;Slides 8
&lt;/h2&gt;&lt;p&gt;which syscall could be sped up?&lt;br&gt;
mo side-effect, return constant value, value can change after entering the kernel&lt;br&gt;
options: getpid() &amp;amp; uptime()&lt;/p&gt;
&lt;p&gt;provide a bitmask for pages accessed&lt;br&gt;
detect page accesses without access bits? use page fault!&lt;br&gt;
TOCTOU attack: argument is modified after the kernel reads it&lt;/p&gt;
&lt;p&gt;chatgpt: reduce the time lap between check and use&lt;/p&gt;
&lt;h2 id=&#34;virtual-syscalls&#34;&gt;virtual syscalls
&lt;/h2&gt;&lt;p&gt;put syscalls access kernel space -&amp;gt; access process addr space, reduce the cost of context switching&lt;br&gt;
vDSO? a library, or a memory region&lt;br&gt;
vDSO is a fully formed ELF image&lt;/p&gt;
&lt;h2 id=&#34;list-balancing&#34;&gt;List Balancing
&lt;/h2&gt;&lt;p&gt;file-backed pages&lt;br&gt;
change of kernel-tracking infrastructure&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE7</title>
        <link>https://vzstless.moe/p/xv6-lecture7/</link>
        <pubDate>Tue, 14 Jan 2025 12:07:31 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture7/</guid>
        <description>&lt;h2 id=&#34;handout-7&#34;&gt;Handout 7
&lt;/h2&gt;&lt;p&gt;VM-related projects: COW, mappings, performance&lt;br&gt;
ideas: isolation, indirection&lt;br&gt;
panic? update page tables when page fault happens&lt;br&gt;
VA causes page fault: stval reg&lt;br&gt;
violation causes page fault: scause reg&lt;br&gt;
instruction/mode can also cause page fault&lt;/p&gt;
&lt;p&gt;if the user program asks for more memory, sbrk() could be expensive&lt;br&gt;
zero-filled page? large part of memory filled with zero&lt;br&gt;
COW or write then copy&lt;/p&gt;
&lt;p&gt;don&amp;rsquo;t let fork() copy every pages from parent&lt;br&gt;
but share addr space between parent and child, use RSW in PTEs&lt;br&gt;
page fault: make copy, map, read/write(hard in real life!)&lt;/p&gt;
&lt;p&gt;load the pages for the file on demand&lt;br&gt;
keep meta information in VMA&lt;/p&gt;
&lt;p&gt;memory-mapping: use load &amp;amp; store to access files&lt;br&gt;
page-in &amp;amp; page-out due to the LRU strategy, especially when the file is larger than the VM page&lt;/p&gt;
&lt;p&gt;KPTI is used to handle meltdown&lt;/p&gt;
&lt;h2 id=&#34;slides&#34;&gt;Slides
&lt;/h2&gt;&lt;p&gt;Modern OSes allocate memory lazily, only allocate memory when user program accesses the memory&lt;br&gt;
COW: make all pages read-only, On page fault, copy page and mark R/W, use extra PTE bits&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-46&#34;&gt;Book Chapter 4.6
&lt;/h2&gt;&lt;p&gt;xv6&amp;rsquo;s response:&lt;br&gt;
kill the faulting process; kernel panic&lt;br&gt;
let child and parent use same block of PM? overwritten!!!
load, store, instruction page faults&lt;br&gt;
COW fork is faster especially in fork just before exec&lt;br&gt;
lazy allocation&lt;br&gt;
demand paging; page to disk&lt;/p&gt;
&lt;h2 id=&#34;the-paper-of-cow&#34;&gt;The Paper of COW
&lt;/h2&gt;&lt;p&gt;&lt;a&gt;&lt;a class=&#34;link&#34; href=&#34;https://lwn.net/Articles/849638/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://lwn.net/Articles/849638/&lt;/a&gt;&lt;/a&gt;
Project Zero issue; CVE-2020-29374&lt;br&gt;
for performance, android doesn&amp;rsquo;t put an exec() just behind fork()&lt;/p&gt;
&lt;p&gt;Xu: Breaking COW by GUP; Tovalds: do_wp_pages()&lt;br&gt;
the new approach breaks RDMA self-tests&lt;/p&gt;
&lt;p&gt;a userfaultfd() was reported&lt;br&gt;
something about the new rules&lt;br&gt;
the way of using RDMA for soft-dirty or userfaultfd() is broken now&lt;/p&gt;
&lt;h2 id=&#34;lecture-7&#34;&gt;Lecture 7
&lt;/h2&gt;&lt;p&gt;page faults can let page mapping from a static map to a dynamic one&lt;br&gt;
information needed: faulted va page, stval register&lt;br&gt;
type of page fault&lt;/p&gt;
&lt;p&gt;when page fault happens:&lt;br&gt;
allocate 1 page, set the page all 0, map the page, restart instruction&lt;br&gt;
what if the process uses up the PM? just kill the process&lt;br&gt;
lazy allocation: the memory not allocated will not be mapped&lt;/p&gt;
&lt;p&gt;free the memory that is not allocated will cause a fault, as the sbrk() let p-&amp;gt;sz go upper&lt;br&gt;
negative number? shrinking addr space, but be careful!!!&lt;/p&gt;
&lt;p&gt;zero-fill on demand&lt;br&gt;
kalloc() a zero page, change the mapping&lt;br&gt;
copy, update, restart&lt;br&gt;
the cost of switching space and storing registers will be huge!!!&lt;/p&gt;
&lt;p&gt;COW fork: use share instead of copy&lt;br&gt;
set all pages read only, receive page fault, copy the page into a new page, map it, restart instruction, call userret()&lt;br&gt;
except trampoline which could never be freed, other physical memory blocks are belonged to two or more different processes&lt;br&gt;
but when to free the page?&lt;/p&gt;
&lt;p&gt;demand paging&lt;br&gt;
exec(): load text, data, segment, eagerly alloc page&lt;br&gt;
read, map, restart&lt;br&gt;
If out of memory: evict, use the just-free-page, restart&lt;br&gt;
evict the clean pages not dirty ones!!!&lt;/p&gt;
&lt;p&gt;mmap(va, len, plot, flags, fd, off)&lt;br&gt;
unmap(va, len), write back dirty block&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE6</title>
        <link>https://vzstless.moe/p/xv6-lecture6/</link>
        <pubDate>Sun, 12 Jan 2025 16:14:43 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture6/</guid>
        <description>&lt;h2 id=&#34;handout-6&#34;&gt;Handout 6
&lt;/h2&gt;&lt;p&gt;focusing on user-&amp;gt;kernel transition&lt;br&gt;
NEVER execute user code in supervisor mode&lt;br&gt;
C on RISC-V puts function arguments in a0, a1, a2, &amp;amp;c&lt;/p&gt;
&lt;p&gt;check pagetables: C-a c, info mem&lt;br&gt;
trampoline: the start of kernel&amp;rsquo;s trap handling code&lt;br&gt;
at the top: avoid punch a hole in user addr&lt;/p&gt;
&lt;p&gt;observe PC is an indirect way to check whether we&amp;rsquo;re in supervisor mode&lt;/p&gt;
&lt;p&gt;ecall:&lt;br&gt;
change mode, save PC in SEPC, jump to STVEC, disable further interrupts&lt;br&gt;
ecall does as little as possible&lt;br&gt;
even supervisor mode is constrained to use pgtbl&lt;/p&gt;
&lt;p&gt;save the user registers:&lt;br&gt;
using trapframe or the sscratch register&lt;/p&gt;
&lt;p&gt;why not a crash? we just switched page tables while executing&lt;br&gt;
the trampoline is mapped at the same addr in pgtbls&lt;/p&gt;
&lt;p&gt;back to usertrap(), return $ and space&lt;br&gt;
usertrapret()&lt;br&gt;
prepare for next transition&lt;br&gt;
use sret instruction&lt;/p&gt;
&lt;p&gt;complex from isolation&lt;br&gt;
what if design for faster?&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-4&#34;&gt;Book Chapter 4
&lt;/h2&gt;&lt;p&gt;ecall &amp;amp; exception will cause a trap&lt;br&gt;
stvec: trap handler&lt;br&gt;
sepc: PC saver&lt;br&gt;
scause: cause of occurring a trap&lt;br&gt;
sscratch: avoid overwriting&lt;br&gt;
usertrap: determine the reason of trap&lt;br&gt;
usertrapret -&amp;gt; userret -&amp;gt; switch satp to user space -&amp;gt; load trapframe addr to a0 -&amp;gt; executes sret&lt;/p&gt;
&lt;p&gt;argint, argaddr, argfd retrieves n&amp;rsquo;th argument of integer, address or fd&lt;br&gt;
kernelvec: save regs, jump to kerneltrap, yield&lt;/p&gt;
&lt;h2 id=&#34;lecture-6&#34;&gt;Lecture 6
&lt;/h2&gt;&lt;p&gt;don&amp;rsquo;t let user code to interfere the transition between user and kernel code&lt;br&gt;
supervisor: R/W control regs, satp, stvec, sepc, sscratch, use PTE/PTE_U&lt;/p&gt;
&lt;p&gt;write() -&amp;gt; ecall -(user-&amp;gt;kernel)-&amp;gt; uservec -&amp;gt; usertrap() -&amp;gt; syscall() &amp;lt;-&amp;gt; sys_write() -&amp;gt; usertrapret() -&amp;gt; userret()&lt;/p&gt;
&lt;p&gt;the user code could only access memory with PTE_U flag&lt;br&gt;
(checking by C-a c, info mem)&lt;br&gt;
csrrw? swaps a0 and special temp register&lt;br&gt;
lack of crash, the status of pc -&amp;gt; we&amp;rsquo;re in supervisor mode&lt;br&gt;
OS cares lot about performance, so ecall never forces you to do stack operations&lt;br&gt;
struct trapframe stays in proc.h, using 32 slots to save registers&lt;/p&gt;
&lt;p&gt;when running shell, sscratch holds the pointer to trapframe&lt;br&gt;
save? beware overwrite&lt;br&gt;
the instructions not executed? we&amp;rsquo;re still in trampoline, where user VA = kernel VA&lt;/p&gt;
&lt;p&gt;what if switch to another process?&lt;br&gt;
we could only switch pgtbl on trampoline&lt;/p&gt;
&lt;p&gt;sret? re-enables interrupts, setting the PC same as sepc, switching user mode&lt;br&gt;
what happens in UIE?&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE5</title>
        <link>https://vzstless.moe/p/xv6-lecture5/</link>
        <pubDate>Thu, 09 Jan 2025 21:52:22 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture5/</guid>
        <description>&lt;h2 id=&#34;gdb&#34;&gt;GDB
&lt;/h2&gt;&lt;p&gt;step: one line of code at a time, jumps into the function&lt;br&gt;
next: jump over functions&lt;br&gt;
stepi, nexti: do same thing for asm code&lt;br&gt;
continue: run until next breakpoint&lt;br&gt;
finish: runs until the function ends&lt;/p&gt;
&lt;p&gt;break: set a breakpoint&lt;br&gt;
watch: stop whenever value changes&lt;br&gt;
x: prints the raw memory&lt;br&gt;
print: prints the expression&lt;br&gt;
info registers: print value of registers&lt;br&gt;
info frame: prints current stack frame&lt;/p&gt;
&lt;p&gt;set: change value of a variable&lt;/p&gt;
&lt;h2 id=&#34;handout-5&#34;&gt;Handout 5
&lt;/h2&gt;&lt;p&gt;overwrite return address will cause an infinite loop&lt;/p&gt;
&lt;h2 id=&#34;calling-conventions&#34;&gt;Calling Conventions
&lt;/h2&gt;&lt;p&gt;int in RISC-V is always 32-bit wide, while long is 32-bit wide in RV32 and 64-bit wide in RV64&lt;br&gt;
in RV64, int is sign-extended&lt;br&gt;
struct: pass first 8 pointer-words into register&lt;br&gt;
twice size as a pointer word: use an even-odd pair; more than twice: pass by reference&lt;/p&gt;
&lt;h2 id=&#34;lecture-5&#34;&gt;Lecture 5
&lt;/h2&gt;&lt;p&gt;since published, x86 adds 3 instructions per month&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.section .test
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.global sum_to
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;definition of .test is at &amp;lt;defs.h&amp;gt;&lt;/p&gt;
&lt;p&gt;focus: switch the layout window in gdb&lt;/p&gt;
&lt;p&gt;tmux:
C-b c: new window&lt;br&gt;
C-b p &amp;amp; C-b n: switch between terminals&lt;br&gt;
C-b %: vertical split&lt;br&gt;
C-b &amp;ldquo;: horizontal split&lt;br&gt;
C-b o: jump between splited windows&lt;/p&gt;
&lt;p&gt;apropos will display gdb built-in manual&lt;/p&gt;
&lt;p&gt;caller: not preserved, callee: preserved&lt;br&gt;
s0-s11 is for? maybe to give compiler flexibility&lt;/p&gt;
&lt;p&gt;stack frame generated by calls&lt;br&gt;
sp-&amp;gt;bottom of the stack&lt;br&gt;
fp-&amp;gt;top of the current frame&lt;/p&gt;
&lt;p&gt;i frame: show the message of stack frame&lt;br&gt;
backtrace&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE4</title>
        <link>https://vzstless.moe/p/xv6-lecture4/</link>
        <pubDate>Tue, 07 Jan 2025 18:57:30 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture4/</guid>
        <description>&lt;h2 id=&#34;handout-4&#34;&gt;Handout 4
&lt;/h2&gt;&lt;p&gt;what if a user program writes to a random part of memory?&lt;br&gt;
what way could we separate and isolate memory?&lt;br&gt;
page tables&lt;br&gt;
a level of indirection: CPU -(VM)&amp;gt; MMU -(PM)&amp;gt; MEM&lt;br&gt;
satp, MMU, kernel&lt;/p&gt;
&lt;p&gt;reduce the size of page tables, not building a direct-map&lt;/p&gt;
&lt;p&gt;page=4KB, maximum 52 bits, nowadays 27bits&lt;br&gt;
page table entry: 64 bits, 54 used, 10 of them are flags, low 12 bits of PA are from VA&lt;br&gt;
3-level page table to reduce its size&lt;br&gt;
a tree descended 9 bits at a time&lt;/p&gt;
&lt;p&gt;page-fault forces transfer to kernel&lt;br&gt;
PHYSTOP = 0x88000000&lt;/p&gt;
&lt;p&gt;the design and arrangement of user address space: easier for compiler to compile&lt;br&gt;
need contingous PM not VM&lt;/p&gt;
&lt;p&gt;kvmmake() makes kernel&amp;rsquo;s page table&lt;br&gt;
kvmmap() adds PTEs to a page table&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-3&#34;&gt;Book Chapter 3
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bits 25  27    12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;VA   EXT index offset
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bits      44  10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pagetable PPN flags
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bits 44    10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PA   index offset
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;TLB: avoid the cost of loading PTE&lt;br&gt;
write PA into satp register&lt;br&gt;
1 page table per process&lt;br&gt;
KERNBASE=0x80000000&lt;br&gt;
fork() uses parent&amp;rsquo;s virtual memory address directly&lt;br&gt;
trampoline and kernel stack aren&amp;rsquo;t directly-mapped&lt;/p&gt;
&lt;p&gt;pagetable_t: a pointer to root page table page&lt;br&gt;
walk() looks up for PTE&amp;rsquo;s VA&lt;br&gt;
instruction sfence.vma flushes CPU&amp;rsquo;s TLB&lt;/p&gt;
&lt;p&gt;allocator: keeps a free list of struct run&lt;br&gt;
kfree: set value to all 1&lt;/p&gt;
&lt;p&gt;refuse to execute, occur a page fault, kill the process and print the message&lt;br&gt;
make exploit attack harder by such a protection process&lt;/p&gt;
&lt;p&gt;sbrk() -&amp;gt; growproc() -&amp;gt; uvmalloc()/uvdemalloc() -&amp;gt; kalloc()/uvmunmap()
exec() -&amp;gt; namei() -&amp;gt; quick check -&amp;gt; proc_pagetable() -&amp;gt; loadseg() -&amp;gt; walkaddr()&lt;/p&gt;
&lt;p&gt;xv6 is lack of malloc()-like allocator to allocate small pieces of space&lt;/p&gt;
&lt;h2 id=&#34;lecture-4&#34;&gt;Lecture 4
&lt;/h2&gt;&lt;p&gt;What do we want from isolation?&lt;/p&gt;
&lt;p&gt;The VA_MAX could be larger than PA_MAX&lt;br&gt;
where does page table allocates? kalloc()&lt;br&gt;
there are 4096 bytes of continuous PA in PM, but not continuous for pages&lt;br&gt;
the size of PM is determined by designers&lt;br&gt;
satp is points to the top directory&lt;/p&gt;
&lt;p&gt;don&amp;rsquo;t use a translation scheme to rely on another translation scheme, so store PA in tables&lt;br&gt;
satp also stores PA&lt;br&gt;
why walk() ? initialization, sysinfo() needs walk()&lt;br&gt;
flexibility stays in dealing with page faults&lt;br&gt;
where will the data store? depends on a &amp;ldquo;multiplexer&amp;rdquo;&lt;br&gt;
mostly-identity mapping is used in kernel mapping&lt;/p&gt;
&lt;p&gt;stack overflow: page fault instead of covering other program&amp;rsquo;s memory&lt;br&gt;
consolidate the mapping? good, but xv6 didn&amp;rsquo;t do this action&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b main
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b kvminit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout src
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b kvminithart
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;where to store satp? in each proc structure, there&amp;rsquo;s a satp&lt;br&gt;
why 3-level not a single big table? you can remain many blocks empty&lt;br&gt;
etext is the last addr of kernel, KERNBASE=0x80000000, etext-KERNBASE=size of kernel&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE3</title>
        <link>https://vzstless.moe/p/xv6-lecture3/</link>
        <pubDate>Sun, 05 Jan 2025 09:49:10 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture3/</guid>
        <description>&lt;h2 id=&#34;handout-3&#34;&gt;Handout 3
&lt;/h2&gt;&lt;p&gt;No OS: lack of isolation&lt;br&gt;
fork() -&amp;gt; abstract core&lt;br&gt;
exec()/sbrk() -&amp;gt; abstract RAM&lt;br&gt;
assumption: user is always willing to break the isolation, while kernel is always trustable&lt;br&gt;
user mode and supervisor mode&lt;br&gt;
pgtbl: maps virtual-&amp;gt;physical&lt;br&gt;
ecall: change to supervisor mode, get to a known point of the kernel code&lt;/p&gt;
&lt;p&gt;Singularity provides a way of process isolation without hardware support&lt;/p&gt;
&lt;p&gt;kernel is a big program holds all of the syscalls&lt;br&gt;
On CVE there&amp;rsquo;s 2997 bugs detected on Linux in 2024(kernel bugs are much more common than we thought)&lt;/p&gt;
&lt;p&gt;build the kernel: make&lt;br&gt;
gcc compiles every .c, .o, linking, kernel/kernel, kernel/kernel.asm, produces an .iso&lt;br&gt;
run the OS: make qemu&lt;br&gt;
simulates the CPU, run into the first instruction in the OS&lt;/p&gt;
&lt;p&gt;kernel/entry.S -&amp;gt; start.c -&amp;gt; main()&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-2&#34;&gt;Book Chapter 2
&lt;/h2&gt;&lt;p&gt;Isolation can be done by protecting sensitive hardware from system calls&lt;br&gt;
monolithic kernel: the whole OS resides in the kernel&lt;br&gt;
micro kernel: minimalize code run in the supervisor mode&lt;br&gt;
in xv6, isolation is done by setting processes&lt;br&gt;
trampoline: contains the code from user space to kernel space&lt;br&gt;
trapframe: protects the status of the process&lt;br&gt;
sret instruction is used to return to user space from kernel space&lt;/p&gt;
&lt;p&gt;process: an addr space as a virtual RAM and an thread as a virtual CPU&lt;/p&gt;
&lt;p&gt;Boot a RISC-V Computer:&lt;br&gt;
power on -&amp;gt; run bootloader -&amp;gt; load kernel into memory address 0x80000000(I/O starts from here) and run into M mode -&amp;gt; set up a stack at _entry for runnning C code -&amp;gt; run into start of C -&amp;gt; program the clock chip to generate timer interrupts -&amp;gt; call useerinit to start the first syscall -&amp;gt; complete exec() -&amp;gt; return to user space and initialize the shell&lt;/p&gt;
&lt;h2 id=&#34;lecture-3&#34;&gt;Lecture 3
&lt;/h2&gt;&lt;p&gt;No strong isolation will cause memory overwrite, which will lead to a bug hard to debug&lt;br&gt;
OS should be defensive&lt;br&gt;
There is a flag to check whether the CPU is at user mode or kernel mode&lt;br&gt;
BIOS is always trustworthy&lt;/p&gt;
&lt;p&gt;fork() as a syscall hasn&amp;rsquo;t its function decalaration&lt;br&gt;
when calling fork: ecall sys_fork (here sys_fork is a number) -&amp;gt; syscall -&amp;gt; find number in a0 -&amp;gt; create a new process&lt;br&gt;
How to get control from buggy useer application? set a timer&lt;/p&gt;
&lt;p&gt;think qemu as a real circuit board&lt;br&gt;
qemu is an infinite for loop: fetch, decode, execute&lt;br&gt;
use gdb: b _entry; c; si; layout src;&lt;br&gt;
use n to goto next line of C code&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-43--44&#34;&gt;Book Chapter 4.3 &amp;amp; 4.4
&lt;/h2&gt;&lt;p&gt;(Before the labs&amp;hellip;)&lt;br&gt;
args for exec() in a0 &amp;amp; a1, syscall number in a7&lt;br&gt;
SYS_exec -&amp;gt; sys_exec&lt;br&gt;
return value in p-&amp;gt;trapframe-&amp;gt;a0&lt;/p&gt;
&lt;p&gt;fetchstr -&amp;gt; copyinstr -&amp;gt; walkaddr -&amp;gt; walk -&amp;gt; pagetable&lt;/p&gt;
&lt;h2 id=&#34;just-before-lab-syscall&#34;&gt;Just before Lab syscall&amp;hellip;
&lt;/h2&gt;&lt;p&gt;installing riscv64-unknown-elf-gdb:&lt;br&gt;
download the tar file from TUNA mirror site, unpack it, enter the current directory&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;../configure --prefix&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/local --target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;riscv64-unknown-elf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make -j &lt;span class=&#34;m&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;using-gdb&#34;&gt;using gdb
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;target remote localhost:26000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;b syscall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout src
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;backtrace
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;p /x *p
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;p /x &lt;span class=&#34;nv&#34;&gt;$sstatus&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>xv6 LECTURE2</title>
        <link>https://vzstless.moe/p/xv6-lecture2/</link>
        <pubDate>Fri, 03 Jan 2025 22:12:02 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture2/</guid>
        <description>&lt;h2 id=&#34;handout-2&#34;&gt;Handout 2
&lt;/h2&gt;&lt;p&gt;memory layout:&lt;br&gt;
text: code, read-only data&lt;br&gt;
data: global C vars&lt;br&gt;
stack: local variables&lt;br&gt;
heap: sbrk, malloc, free&lt;br&gt;
.c -compile-&amp;gt; .o -link-&amp;gt; executable file&lt;br&gt;
strlen() uses array access while strcmp() uses pointer access&lt;br&gt;
kalloc() keeps a large linked list of free pages of memory&lt;br&gt;
LRU buffer cache is implemented as a dual-pointer linked list&lt;br&gt;
static: limited to the file where the variable is declared&lt;/p&gt;
&lt;h2 id=&#34;slides&#34;&gt;Slides
&lt;/h2&gt;&lt;p&gt;This class focus on RAM and I/O&lt;br&gt;
address space: represent bus as a giant array of data&lt;br&gt;
memory allocation: decide where array to store things&lt;br&gt;
A stack is much more smaller than heap&lt;/p&gt;
&lt;h2 id=&#34;kr&#34;&gt;K&amp;amp;R
&lt;/h2&gt;&lt;p&gt;alloc: use a stack to allocate memory space&lt;br&gt;
afree: pop the space and decrease the pointer&lt;br&gt;
the behavior is undefined for arithmetic or comparisons with pointers that do not point to members of the same array&lt;br&gt;
size_t is uint returned by sizeof()&lt;br&gt;
the result of modifying the string pointer is undefined&lt;/p&gt;
</description>
        </item>
        <item>
        <title>xv6 LECTURE1</title>
        <link>https://vzstless.moe/p/xv6-lecture1/</link>
        <pubDate>Wed, 01 Jan 2025 08:28:39 +0800</pubDate>
        
        <guid>https://vzstless.moe/p/xv6-lecture1/</guid>
        <description>&lt;h2 id=&#34;handout-1&#34;&gt;Handout 1
&lt;/h2&gt;&lt;p&gt;Purpose of an OS:&lt;/p&gt;
&lt;p&gt;Isolate hard/software, virtualize hardware&lt;br&gt;
Interact with OS via syscalls&lt;br&gt;
First arg in syscall is FD&lt;br&gt;
UNIX I/O is 8-bit bytes&lt;/p&gt;
&lt;p&gt;When CPU receives a syscall:&lt;br&gt;
save, jump, execute, call, restore, reduce, jump back&lt;/p&gt;
&lt;p&gt;Shell is a user program instead of shell&lt;br&gt;
fork() lets us create a new process&lt;br&gt;
exec() replaces current process with an executable file&lt;/p&gt;
&lt;h2 id=&#34;book-chapter-1&#34;&gt;Book Chapter 1
&lt;/h2&gt;&lt;p&gt;Operating system let different softwares use hardware together&lt;br&gt;
Process: instructions, data, stack&lt;br&gt;
fork() returns 0 in the child process while pid in the parent process&lt;br&gt;
wait() returns the pid and copies the exit status&lt;br&gt;
exec() loads a file and executes it&lt;/p&gt;
&lt;p&gt;file descripter refers to a file.&lt;br&gt;
fork() and exec()let the shell has the chance to redirect child&amp;rsquo;s I/O&lt;br&gt;
File descripter is a good abstraction&lt;/p&gt;
&lt;p&gt;Pipe is a small kernel buffer conncting files.&lt;br&gt;
Pipe: auto-clean, pass long data, allow parallel execution&lt;/p&gt;
&lt;p&gt;Underlying file is called inode&lt;br&gt;
cd is built-in, if not, the shell will form a infinity process tree of dir-changing&lt;/p&gt;
&lt;p&gt;ALL XV6 PROGRAMS RUN AS ROOT!!!!!&lt;/p&gt;
&lt;h2 id=&#34;amusement-unix&#34;&gt;Amusement: UNIX
&lt;/h2&gt;&lt;p&gt;In order to avoid large amount of team population and project cost, we need to build a good programming environment. UNIX is for building such an environment.&lt;br&gt;
PROBLEM: Large number of softwares, large scale of jobs&lt;br&gt;
Software is always demanded for different operations, to avoid rewrite code per annum, the code should be divided into modules.
Layers: kernel, shell, util&lt;br&gt;
A show of pipes&lt;br&gt;
Easy and packed pattern-matching algorithms&lt;br&gt;
Refer file as a simple sequence of bytes, file is contained in directories&lt;br&gt;
Concept of I/O redirection&lt;br&gt;
C: If you need to avoid hardware, simply use it; but also ways to interact with hardware directly&lt;br&gt;
An example of a software, inputting boolean equation and outputting circuit traces&lt;br&gt;
Computer is built for easy to use&lt;/p&gt;
&lt;h2 id=&#34;lecture-1&#34;&gt;Lecture 1
&lt;/h2&gt;&lt;p&gt;What would a kernel do?&lt;br&gt;
Everyone thought OS provides what they already know&lt;br&gt;
Many tensions occurred in OS design&lt;br&gt;
Func call vs Syscall? func hasn&amp;rsquo;t previlege to access real CPU and mem but syscalls have&lt;br&gt;
High-level language is designed to be portable&lt;br&gt;
There is a rule that we read from fd 0 and write to fd 1&lt;br&gt;
Kernel holds a process table and guided by fd&lt;br&gt;
Instruction ecall passes the system from user space to the kernel space&lt;br&gt;
Parent and child process shares the same fd&lt;br&gt;
exec() loads the program in the file and throw away current process&lt;br&gt;
exec() remains the fd that already exists&lt;br&gt;
wait() waits the child process to return, if the process hasn&amp;rsquo;t child process, it&amp;rsquo;ll return -1&lt;/p&gt;
&lt;h2 id=&#34;just-before-lab-util&#34;&gt;Just before Lab util&amp;hellip;
&lt;/h2&gt;&lt;p&gt;installing the riscv64-unknown-elf-gcc:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install &lt;span class=&#34;nv&#34;&gt;gcc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;riscv64-unknown-elf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
